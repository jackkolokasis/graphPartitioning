package org.apache.spark.sql.catalyst.optimizer;
/**
 * Collapse plans consisting empty local relations generated by {@link PruneFilters}.
 * 1. Binary(or Higher)-node Logical Plans
 *    - Union with all empty children.
 *    - Join with one or two empty children (including Intersect/Except).
 * 2. Unary-node Logical Plans
 *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.
 *    - Aggregate with all empty children and without AggregateFunction expressions like COUNT.
 *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.
 */
public  class PropagateEmptyRelation$ extends org.apache.spark.sql.catalyst.rules.Rule<org.apache.spark.sql.catalyst.plans.logical.LogicalPlan> implements org.apache.spark.sql.catalyst.expressions.PredicateHelper {
  /**
   * Static reference to the singleton instance of this Scala object.
   */
  public static final PropagateEmptyRelation$ MODULE$ = null;
  public   PropagateEmptyRelation$ ()  { throw new RuntimeException(); }
  private  boolean isEmptyLocalRelation (org.apache.spark.sql.catalyst.plans.logical.LogicalPlan plan)  { throw new RuntimeException(); }
  private  boolean containsAggregateExpression (org.apache.spark.sql.catalyst.expressions.Expression e)  { throw new RuntimeException(); }
  private  org.apache.spark.sql.catalyst.plans.logical.LocalRelation empty (org.apache.spark.sql.catalyst.plans.logical.LogicalPlan plan)  { throw new RuntimeException(); }
  public  org.apache.spark.sql.catalyst.plans.logical.LogicalPlan apply (org.apache.spark.sql.catalyst.plans.logical.LogicalPlan plan)  { throw new RuntimeException(); }
}
